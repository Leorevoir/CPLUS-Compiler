#include <CPlus/Codegen/x86-64Codegen.hpp>

#include <sstream>

/**
* public
*/

const std::string cplus::x86_64::Codegen::run(const std::string &ir)
{
    _ir = std::move(ir);
    _output.clear();

    _prologue();
    _generate();

    return _output;
}

/**
 * helpers
 */

static const std::string _get_module_name(const std::string &ir)
{
    const cplus::u64 module = ir.find("module ");

    if (module == std::string::npos) {
        return "";
    }

    const cplus::u64 start = module + 7;
    const cplus::u64 end = ir.find_first_of("\n\r\t", start);

    if (end == std::string::npos) {
        return ir.substr(start);
    }

    return ir.substr(start, end - start);
}

static inline void _trim(std::string &s)
{
    const cplus::u64 first = s.find_first_not_of(" \t\n\r");
    const cplus::u64 last = s.find_last_not_of(" \t\n\r");

    if (first == std::string::npos || last == std::string::npos) {
        s.clear();
    } else {
        s = s.substr(first, last - first + 1);
    }
}

/**
 * @brief count slots
 * @info counts the number of slots in the function body
 */
static cplus::u64 _count_slots(const std::string_view body)
{
    cplus::u64 count = 0;
    cplus::u64 pos = 0;

    while (pos < body.size()) {
        const cplus::u64 p = body.find('%', pos);

        if (p == std::string_view::npos) {
            break;
        }

        const cplus::u64 eq = body.find('=', p);

        if (eq != std::string_view::npos) {
            const std::string_view tmp = body.substr(p, eq - p);

            if (tmp.find("arg") == std::string_view::npos) {
                ++count;
            }
        }
        pos = eq != std::string_view::npos ? eq + 1 : p + 1;
    }
    return count;
}

/**
 * @brief align size to 16 bytes
 * @info aligns the given size to the next multiple of 16 for SIMD vectorisation & stack alignment
 */
static inline cplus::u64 _align16(const cplus::u64 size)
{
    return (size + 15) & ~static_cast<cplus::u64>(15);
}

/**
* @brief set function stack  offset
* @info sets the stack offset for the current function based on the number of slots used
*
* keep the stack aligned to 16 byte for SIMD vectorisation
*/
static inline void _function_set_stack_offset(cplus::u64 *offset, const std::string &ir, const std::string &current_function)
{

    const cplus::u64 start = ir.find('{', ir.find("func @" + current_function));
    const cplus::u64 end = ir.find('}', start);

    if (start != std::string::npos && end != std::string::npos) {
        const std::string_view body{ir.data() + start + 1, end - start - 1};
        const cplus::u64 slots = _count_slots(body);

        *offset = _align16(slots * 8);
    } else {
        *offset = 0;
    }
}

/**
* private
*/

/**
 * @brief emit line to the output with newline
 */
void cplus::x86_64::Codegen::_emit(const std::string &s)
{
    _output += s;
    _output += '\n';
}

/**
 * @brief emit prologue
 * @info the syntax is Intel Syntax
 */
void cplus::x86_64::Codegen::_prologue()
{
    _emit("# x86-64 Assembly generated by CPlus Compiler");
    _emit("\t.intel_syntax\tnoprefix");
    _emit("\t.file\t\t\t\"" + _get_module_name(_ir) + "\"");
    _emit("\t.section\t\t.text\n");
}

/**
 * @brief generate x86-64 code from IR
 * @info foreach (line in _ir) { _emit(line); }
 */
void cplus::x86_64::Codegen::_generate()
{
    std::istringstream stream(_ir);
    std::string line;

    while (std::getline(stream, line)) {
        _trim(line);
        _generate_line(line);
    }
}

/**
 * @brief generate line
 * @info dispatch line to the appropriate emitter
 */
void cplus::x86_64::Codegen::_generate_line(const std::string &line)
{
    if (line.empty() || line.starts_with(";")) {
        return;
    }

    if (line.starts_with("func ")) {
        _emit_function_declaration(line);
    } else if (line == "{") {
        _emit_function_start();
    } else if (line == "}") {
        _emit_function_end();
    } else if (line.starts_with("label %")) {
        _emit_label(line);
    } else if (line.starts_with("call @")) {
        _emit_function_call(line);
    }
}

/**
* @brief functions
*
* @info routine:
*
* .globl        name
* name:    
*     push      rbp
*     mov       rbp, rsp
*     sub       rsp, <stack_size>
*     <function_body>
*     leave
*     ret
*/

/**
* @brief emit function declaration
*/
void cplus::x86_64::Codegen::_emit_function_declaration(const std::string &line)
{
    const std::string_view sv(line);

    if (!sv.starts_with("func @")) {
        return;
    }

    const u64 start = 6;
    const u64 end = sv.find('(', start);

    if (end == std::string::npos) {
        return;
    }

    const std::string_view func_name = sv.substr(start, end - start);

    _current_function = std::string(func_name);
    _emit(".globl\t\t\t" + _current_function);
    _emit(_current_function + ":");
    _function_set_stack_offset(&_stack_offset, _ir, _current_function);
}

/**
* @brief emit function start
*/
void cplus::x86_64::Codegen::_emit_function_start()
{
    _emit("\tpush\trbp");
    _emit("\tmov\t\trbp, rsp");

    if (_stack_offset > 0) {
        _emit("\tsub\t\trsp, " + std::to_string(_stack_offset));
    }
}

/**
 * @brief emit function end
*/
void cplus::x86_64::Codegen::_emit_function_end()
{
    if (_stack_offset > 0) {
        _emit("\tadd\t\trsp, " + std::to_string(_stack_offset));
    }

    _emit("\tleave");
    _emit("\tret\n");
    _current_function.clear();
    _stack_offset = 0;
}

void cplus::x86_64::Codegen::_emit_label(const std::string &line)
{
    std::string label = line.substr(6);

    if (!label.empty() && label.back() == ':') {
        label.pop_back();
    }

    if (label.starts_with('%')) {
        label = label.substr(1);
    }

    _emit(".L" + label + ":");
}

void cplus::x86_64::Codegen::_emit_function_call(const std::string &line)
{
    const auto paren_pos = line.find('(');
    std::string rest = (paren_pos == std::string::npos) ? line.substr(6) : line.substr(6, paren_pos - 6);

    rest.erase(rest.find_last_not_of(" \t") + 1);
    rest.erase(0, rest.find_first_not_of(" \t"));
    _emit("\tcall\t" + rest);
}
