#include <CPlus/Codegen/x86-64Codegen.hpp>

#include <regex>
#include <sstream>

/**
 * public
 */

const std::string cplus::x86_64::Codegen::run(const std::string &ir)
{
    _ir = std::move(ir);
    _output.clear();
    _stack_offset = 0;

    _prologue();
    _generate();
    _epilogue();

    return _output;
}

/**
 * helpers
 */

static constexpr const std::string REGISTERS[6] = {"edi", "esi", "edx", "ecx", "r8d", "r9d"};

static constexpr const std::string _get_compare_instruction(const std::string &op)
{
    if (op == "icmp.eq") {
        return "sete";
    }
    if (op == "icmp.ne") {
        return "setne";
    }
    if (op == "icmp.slt") {
        return "setl";
    }
    if (op == "icmp.sle") {
        return "setle";
    }
    if (op == "icmp.sgt") {
        return "setg";
    }
    if (op == "icmp.sge") {
        return "setge";
    }
    return "sete";
}

static const std::string _get_module_name(const std::string &ir)
{
    const cplus::u64 module = ir.find("module ");

    if (module == std::string::npos) {
        return "";
    }

    const cplus::u64 start = module + 7;
    const cplus::u64 end = ir.find_first_of("\n\r\t", start);

    if (end == std::string::npos) {
        return ir.substr(start);
    }

    return ir.substr(start, end - start);
}

static inline void _trim(std::string &s)
{
    const cplus::u64 first = s.find_first_not_of(" \t\n\r");
    const cplus::u64 last = s.find_last_not_of(" \t\n\r");

    if (first == std::string::npos || last == std::string::npos) {
        s.clear();
    } else {
        s = s.substr(first, last - first + 1);
    }
}

/**
 * @brief count slots
 * @info counts every slots except immediates/temporary values
 * TODO: no regex maybe std::string_view for faster iteration
 */
static cplus::u64 _count_slots(const std::string_view body)
{
    const std::regex slot_re(R"(%([a-zA-Z0-9_]+)\s*=\s*(.*))");
    std::smatch match;
    cplus::u64 count = 0;
    const std::string s{body};
    std::string::const_iterator search(s.cbegin());

    while (std::regex_search(search, s.cend(), match, slot_re)) {
        const std::string var = match[1];
        const std::string rhs = match[2];

        if (var.size() > 1 && (var[0] == 'n' && isdigit(var[1]))) {
            search = match.suffix().first;
            continue;
        }
        if (var.size() > 1 && (var[0] == 't' || rhs.find("call") == std::string::npos)) {
            search = match.suffix().first;
            continue;
        }
        ++count;
        search = match.suffix().first;
    }

    return count;
}

/**
 * @brief function set stack offset
 * @info align the stack with %16 according to ABI System V convention
 */
static inline void _function_set_stack_offset(cplus::u64 *offset, const std::string &ir, const std::string &current_function)
{
    const cplus::u64 start = ir.find('{', ir.find("func @" + current_function));
    const cplus::u64 end = ir.find('}', start);

    if (start == std::string::npos || end == std::string::npos) {
        *offset = 0;
        return;
    }

    const std::string_view body{ir.data() + start + 1, end - start - 1};
    const cplus::u64 slots = _count_slots(body);
    const cplus::u64 stack_size = slots * 8;
    const cplus::u64 total_before_call = stack_size + 16;
    cplus::u64 padding = (16 - (total_before_call % 16)) % 16;
    const bool is_recursive = body.find("call @" + current_function) != std::string::npos;

    if (is_recursive && (stack_size % 16 == 0)) {
        padding += 8;
    }

    *offset = stack_size + padding;
}

/**
 * private
 */

void cplus::x86_64::Codegen::_emit(const std::string &s)
{
    _output += s;
    _output += '\n';
}

void cplus::x86_64::Codegen::_prologue()
{
    _emit("# x86-64 Intel Assembly generated by CPlus Compiler");
    _emit("\t.intel_syntax\tnoprefix");
    _emit("\t.file\t\t\t\"" + _get_module_name(_ir) + "\"");
    _emit("\t.section\t\t.text\n");
}

void cplus::x86_64::Codegen::_epilogue()
{
    _emit("\n.globl\t\t\t_start");
    _emit("_start:");
    _emit("\tcall\tmain");
    _emit("\tmov\t\trdi, rax");
    _emit("\tmov\t\trax, 60");
    _emit("\tsyscall");
}

/**
 * @brief get stack location
 * @info returns the stack location of a variable, if not found, allocates a new slot
 */
const std::string cplus::x86_64::Codegen::_get_stack_location(const std::string &var)
{
    if (_var_locations.find(var) == _var_locations.end()) {
        _var_locations[var] = "dword ptr [rbp" + std::to_string(_next_stack_offset) + "]";
        _next_stack_offset -= 4;
    }
    return _var_locations[var];
}

/**
 * @brief parse operand
 * @info as the title says
 */
const std::string cplus::x86_64::Codegen::_get_operand(const std::string &operand)
{
    std::string op = operand;
    _trim(op);

    if (op.starts_with("imm.i32 ")) {
        return op.substr(8);
    }
    if (op.starts_with("imm.bool ")) {
        return op.substr(9);
    }
    if (op.starts_with("const.i32")) {
        return op.substr(9);
    }
    if (op.starts_with("%")) {
        return _get_stack_location(op);
    }
    return op;
}

void cplus::x86_64::Codegen::_generate()
{
    std::istringstream stream(_ir);
    std::string line;

    while (std::getline(stream, line)) {
        _trim(line);
        _generate_line(line);
    }
}

/**
 * @brief generate line
 * @info emits line to valid Intel x86-64
 */
void cplus::x86_64::Codegen::_generate_line(const std::string &line)
{
    if (line.empty() || line.starts_with(";")) {
        return;
    }

    if (line.starts_with("%") && line.find(" = ") != std::string::npos) {
        _emit_assignement(line);
    } else if (line.starts_with("func ")) {
        _emit_function_declaration(line);
    } else if (line == "{") {
        _emit_function_start();
    } else if (line == "}") {
        _emit_function_end();
    } else if (line.starts_with("label %")) {
        _emit_label(line);
    } else if (line.starts_with("br")) {
        _emit_branch(line);
    } else if (line.starts_with("ret")) {
        _emit_return(line);
    }
}

/**
 * @brief function prologue
 * @info let the function "hello_world":
 *
 * .globl			hello_world
 * hello_world:
 */
void cplus::x86_64::Codegen::_emit_function_declaration(const std::string &line)
{
    const std::string_view sv(line);
    const u64 start = 6;
    const u64 end = sv.find('(', start);

    if (end == std::string::npos) {
        return;
    }

    const std::string_view func_name = sv.substr(start, end - start);

    _current_function = std::string(func_name);
    _emit(".globl\t\t\t" + _current_function);
    _emit(_current_function + ":");
    _function_set_stack_offset(&_stack_offset, _ir, _current_function);
}

/**
 * @brief function start
 * @info let the function "hello_world" be:
 *
 * push    rbp
 * mov     rbp, rsp
 * sub     rsp, sizeof(stack_offset)%16
 */
void cplus::x86_64::Codegen::_emit_function_start()
{
    _emit("\tpush\trbp");
    _emit("\tmov\t\trbp, rsp");
    if (_stack_offset > 0) {
        _emit("\tsub\t\trsp, " + std::to_string(_stack_offset));
    }
    _register_index = 0;
    _var_locations.clear();
    _next_stack_offset = -4;
}

/**
 * @brief function end
 * @info just clear the stack 
 */
void cplus::x86_64::Codegen::_emit_function_end()
{
    _emit("");
    _current_function.clear();
    _stack_offset = 0;
    _register_index = 0;
    _var_locations.clear();
}

/**
 * @brief emit label
 * @info let label %if.then0:
 *
 * .Lif.then0:
 */
void cplus::x86_64::Codegen::_emit_label(const std::string &line)
{
    std::string label = line.substr(6);

    if (!label.empty() && label.back() == ':') {
        label.pop_back();
    }
    if (label.starts_with('%')) {
        label = label.substr(1);
    }
    _emit(".L" + label + ":");
}

/**
 * @brief emit call instruction
 * @info called by _emit_assignement to handle the "call @..." expression
 * let the result of the call in `eax` register
 */
void cplus::x86_64::Codegen::_emit_call_instruction(const std::string &call_expr)
{
    const u64 at_pos = call_expr.find('@');
    const u64 paren_start = call_expr.find('(', at_pos);
    const u64 paren_end = call_expr.find(')', paren_start);

    if (at_pos == std::string::npos || paren_start == std::string::npos || paren_end == std::string::npos) {
        return;
    }

    const std::string func_name = call_expr.substr(at_pos + 1, paren_start - at_pos - 1);
    const std::string args_str = call_expr.substr(paren_start + 1, paren_end - paren_start - 1);

    /** @brief get args */
    std::vector<std::string> args;
    if (!args_str.empty()) {
        std::istringstream ss(args_str);
        std::string arg;

        while (std::getline(ss, arg, ',')) {
            _trim(arg);
            if (!arg.empty()) {
                args.push_back(arg);
            }
        }
    }

    /** @brief and emit them according to their register */
    for (u64 i = 0; i < args.size() && i < 6; ++i) {
        const std::string arg_parsed = _get_operand(args[i]);
        const std::string reg32 = REGISTERS[i];

        if (arg_parsed.find('[') != std::string::npos) {
            _emit("\tmov\t\teax, " + arg_parsed);
            _emit("\tmov\t\t" + reg32 + ", eax");
        } else {
            _emit("\tmov\t\t" + reg32 + ", " + arg_parsed);
        }
    }

    _emit("\tcall\t" + func_name);
}

/**
 * @brief emit assignement
 * @info if the right-hand is a `call`, emits the call & immediatly saves the result from `eax` to the dest variable's slot.
 */
void cplus::x86_64::Codegen::_emit_assignement(const std::string &line)
{
    const u64 eq_pos = line.find('=');

    if (eq_pos == std::string::npos) {
        return;
    }

    std::string lhs = line.substr(0, eq_pos);
    std::string rhs = line.substr(eq_pos + 2);
    _trim(lhs);
    _trim(rhs);

    if (rhs.starts_with("call @")) {
        _emit_call_instruction(rhs);
        const std::string dest_loc = _get_stack_location(lhs);
        _emit("\tmov\t\t" + dest_loc + ", eax");
    } else if (rhs.starts_with("mov ")) {
        _emit_mov(lhs, rhs.substr(4));
    } else if (rhs.starts_with("add ")) {
        _emit_binary_op(lhs, rhs, "add");
    } else if (rhs.starts_with("sub ")) {
        _emit_binary_op(lhs, rhs, "sub");
    } else if (rhs.starts_with("mul ")) {
        _emit_binary_op(lhs, rhs, "imul");
    } else if (rhs.starts_with("sdiv ")) {
        _emit_div(lhs, rhs);
    } else if (rhs.starts_with("srem ")) {
        _emit_div(lhs, rhs, true);
    } else if (rhs.starts_with("icmp.")) {
        _emit_compare(lhs, rhs);
    } else if (rhs.starts_with("neg ")) {
        _emit_unary_op(lhs, rhs, "neg");
    } else if (rhs.starts_with("and ")) {
        _emit_binary_op(lhs, rhs, "and");
    } else if (rhs.starts_with("or ")) {
        _emit_binary_op(lhs, rhs, "or");
    } else if (rhs.starts_with("arg ")) {
        _emit_arg_load(lhs, rhs);
    } else if (rhs.starts_with("phi ")) {
        _emit_phi(lhs, rhs);
    } else if (rhs == "undef") {
        _emit("\t# " + lhs + " = undef");
    }
}

/**
* @brief emit mov
* @info if the source is a memory location, uses `eax` as a temporary
*/
void cplus::x86_64::Codegen::_emit_mov(const std::string &dest, const std::string &src)
{
    const std::string src_parsed = _get_operand(src);
    const std::string dest_loc = _get_stack_location(dest);

    if (src_parsed.find('[') != std::string::npos) {
        _emit("\tmov\t\teax, " + src_parsed);
        _emit("\tmov\t\t" + dest_loc + ", eax");
    } else {
        _emit("\tmov\t\t" + dest_loc + ", " + src_parsed);
    }
}

/**
* @brief emit binary operation
* @info handles `add`, `sub`, `mul`, `and`, `or`
*/
void cplus::x86_64::Codegen::_emit_binary_op(const std::string &dest, const std::string &rhs, const std::string &op)
{
    const u64 comma_pos = rhs.find(',');

    if (comma_pos == std::string::npos) {
        return;
    }

    const std::string op_part = rhs.substr(0, rhs.find(' '));
    const std::string left_op = rhs.substr(op_part.length() + 1, comma_pos - op_part.length() - 1);
    const std::string right_op = rhs.substr(comma_pos + 2);
    const std::string left_parsed = _get_operand(left_op);
    const std::string right_parsed = _get_operand(right_op);
    const std::string dest_loc = _get_stack_location(dest);

    _emit("\tmov\t\teax, " + left_parsed);
    _emit("\t" + op + "\t\teax, " + right_parsed);
    _emit("\tmov\t\t" + dest_loc + ", eax");
}

/**
* @brief emit division
*/
void cplus::x86_64::Codegen::_emit_div(const std::string &dest, const std::string &rhs, const bool is_mod)
{
    const u64 comma_pos = rhs.find(',');

    if (comma_pos == std::string::npos) {
        return;
    }

    const std::string left_op = rhs.substr(5, comma_pos - 5);
    const std::string right_op = rhs.substr(comma_pos + 2);
    const std::string left_parsed = _get_operand(left_op);
    const std::string right_parsed = _get_operand(right_op);
    const std::string dest_loc = _get_stack_location(dest);

    _emit("\tmov\t\teax, " + left_parsed);
    _emit("\tcqo");
    _emit("\tmov\t\trcx, " + right_parsed);
    _emit("\tidiv\trcx");

    if (is_mod) {
        _emit("\tmov\t\t" + dest_loc + ", rdx");
    } else {
        _emit("\tmov\t\t" + dest_loc + ", eax");
    }
}

/**
* @brief emit comparison
* @info handles `icmp.eq`, `icmp.ne`, `icmp.slt`, `icmp.sle`, `icmp.sgt`, `icmp.sge`
*/
void cplus::x86_64::Codegen::_emit_compare(const std::string &dest, const std::string &rhs)
{
    const u64 comma_pos = rhs.find(',');

    if (comma_pos == std::string::npos) {
        return;
    }

    const std::string op = rhs.substr(0, rhs.find(' '));
    const std::string left_op = rhs.substr(op.length() + 1, comma_pos - op.length() - 1);
    const std::string right_op = rhs.substr(comma_pos + 2);
    const std::string left_parsed = _get_operand(left_op);
    const std::string right_parsed = _get_operand(right_op);
    const std::string dest_loc = _get_stack_location(dest);

    _emit("\tmov\t\teax, " + left_parsed);
    _emit("\tcmp\t\teax, " + right_parsed);

    const std::string set_instr = _get_compare_instruction(op);

    _emit("\t" + set_instr + "\tal");
    _emit("\tmovzx\teax, al");
    _emit("\tmov\t\t" + dest_loc + ", eax");
}

/**
* @brief emit unary operation
*/
void cplus::x86_64::Codegen::_emit_unary_op(const std::string &dest, const std::string &rhs, const std::string &op)
{
    const std::string operand = rhs.substr(op.length() + 1);
    const std::string operand_parsed = _get_operand(operand);
    const std::string dest_loc = _get_stack_location(dest);

    _emit("\tmov\t\teax, " + operand_parsed);
    _emit("\t" + op + "\t\teax");
    _emit("\tmov\t\t" + dest_loc + ", eax");
}

/**
* @brief emit argument load
* @info loads the argument from register or stack to the destination variable's slot
*/
void cplus::x86_64::Codegen::_emit_arg_load(const std::string &dest, const std::string &rhs)
{
    const std::string arg_num = rhs.substr(4);
    const i32 arg_index = std::stoi(arg_num);
    const std::string dest_loc = _get_stack_location(dest);

    if (arg_index < 6) {
        _emit("\tmov\t\t" + dest_loc + ", " + REGISTERS[arg_index]);
    } else {
        const i32 stack_arg_offset = (arg_index - 6 + 2) * 8;

        _emit("\tmov\t\teax, dword ptr [rbp+" + std::to_string(stack_arg_offset) + "]");
        _emit("\tmov\t\t" + dest_loc + ", eax");
    }
}

/**
* @brief emit phi
* @info phi nodes are (or should be) resolved by control flow
*/
void cplus::x86_64::Codegen::_emit_phi(const std::string &dest, const std::string &rhs)
{
    _emit("\t# " + dest + " = " + rhs + " (phi resolved by control flow)");
}

/**
* @brief emit branch
* @info handles both unconditional and conditional branches
*/
void cplus::x86_64::Codegen::_emit_branch(const std::string &line)
{
    const u64 first_comma = line.find(',');

    if (first_comma == std::string::npos) {
        std::string label = line.substr(3);
        _trim(label);

        if (label.starts_with('%')) {
            label = label.substr(1);
        }

        _emit("\tjmp\t\t.L" + label);

    } else {

        const std::string cond_var = line.substr(3, first_comma - 3);
        const u64 second_comma = line.find(',', first_comma + 1);
        const std::string else_label = line.substr(second_comma + 2);
        const std::string cond_loc = _get_operand(cond_var);
        std::string else_clean = else_label;

        _trim(else_clean);
        if (else_clean.starts_with('%')) {
            else_clean = else_clean.substr(1);
        }

        _emit("\tmov\t\teax, " + cond_loc);
        _emit("\tcmp\t\teax, 0");
        _emit("\tje\t\t.L" + else_clean);
    }
}

/**
* @brief emit return
* @info handles both `ret` and `ret <value>`
*/
void cplus::x86_64::Codegen::_emit_return(const std::string &line)
{
    if (line == "ret") {
        _emit("\tleave");
        _emit("\tret");

    } else if (line.starts_with("ret ")) {
        const std::string value = line.substr(4);
        const std::string value_parsed = _get_operand(value);

        _emit("\tmov\t\teax, " + value_parsed);
        _emit("\tleave");
        _emit("\tret");
    }
}
