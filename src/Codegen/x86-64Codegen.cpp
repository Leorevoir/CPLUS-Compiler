#include "CPlus/Logger.hpp"
#include <CPlus/Codegen/x86-64Codegen.hpp>

#include <regex>
#include <sstream>

/**
* public
*/

const std::string cplus::x86_64::Codegen::run(const std::string &ir)
{
    _ir = std::move(ir);
    _output.clear();
    _stack_offset = 0;

    _prologue();
    _generate();
    _epilogue();

    return _output;
}

/**
 * helpers
 */

static const std::string _get_module_name(const std::string &ir)
{
    const cplus::u64 module = ir.find("module ");

    if (module == std::string::npos) {
        return "";
    }

    const cplus::u64 start = module + 7;
    const cplus::u64 end = ir.find_first_of("\n\r\t", start);

    if (end == std::string::npos) {
        return ir.substr(start);
    }

    return ir.substr(start, end - start);
}

static inline void _trim(std::string &s)
{
    const cplus::u64 first = s.find_first_not_of(" \t\n\r");
    const cplus::u64 last = s.find_last_not_of(" \t\n\r");

    if (first == std::string::npos || last == std::string::npos) {
        s.clear();
    } else {
        s = s.substr(first, last - first + 1);
    }
}

/**
 * @brief count slots as GCC stack would allocate using regex
 * @info counts only what ends up in stack slots: call results or local variables, ignoring args and temps
 */
static cplus::u64 _count_slots(const std::string_view body)
{
    std::regex slot_re(R"(%([a-zA-Z0-9_]+)\s*=\s*(.*))");
    std::smatch match;
    cplus::u64 count = 0;
    std::string s{body};
    std::string::const_iterator search(s.cbegin());

    while (std::regex_search(search, s.cend(), match, slot_re)) {
        const std::string var = match[1];
        const std::string rhs = match[2];

        /** @brief dont count numbered vars */
        if (var.size() > 1 && (var[0] == 'n' && isdigit(var[1]))) {
            search = match.suffix().first;
            continue;
        }

        /** @brief dont count temps */
        if (var.size() > 1 && (var[0] == 't' || rhs.find("call") == std::string::npos)) {
            search = match.suffix().first;
            continue;
        }

        ++count;
        search = match.suffix().first;
    }

    return count;
}

/**
* @brief set function stack  offset
* @info sets the stack offset for the current function based on the number of slots used
*
* keep the stack aligned to 16 byte for ABI System V convention
*/
static inline void _function_set_stack_offset(cplus::u64 *offset, const std::string &ir, const std::string &current_function)
{
    const cplus::u64 start = ir.find('{', ir.find("func @" + current_function));
    const cplus::u64 end = ir.find('}', start);

    if (start == std::string::npos || end == std::string::npos) {
        *offset = 0;
        return;
    }

    const std::string_view body{ir.data() + start + 1, end - start - 1};
    const cplus::u64 slots = _count_slots(body);

    const cplus::u64 stack_size = slots * 8;
    cplus::u64 padding = (16 - (stack_size % 16)) % 16;

    /** @brief recursive functions needs extra padding to keep rsp aligned before call */
    const bool is_recursive = body.find("call @" + current_function) != std::string::npos;

    if (is_recursive) {

        /** @brief add 8 bytes if stack_size is already multiple of 16 */
        if (stack_size % 16 == 0) {
            padding += 8;
        }
    }

    *offset = stack_size + padding;
}

/**
* private
*/

/**
 * @brief emit line to the output with newline
 */
void cplus::x86_64::Codegen::_emit(const std::string &s)
{
    _output += s;
    _output += '\n';
}

/**
 * @brief emit prologue
 * @info the syntax is Intel Syntax
 */
void cplus::x86_64::Codegen::_prologue()
{
    _emit("# x86-64 Assembly generated by CPlus Compiler");
    _emit("\t.intel_syntax\tnoprefix");
    _emit("\t.file\t\t\t\"" + _get_module_name(_ir) + "\"");
    _emit("\t.section\t\t.text\n");
}

/**
 * @brief emit epilogue
 * @info for debug purposes will be later moved to a separeted linker script
 */
void cplus::x86_64::Codegen::_epilogue()
{
    _emit("\n.globl\t\t\t_start");
    _emit("_start:");
    _emit("\tcall\tmain");
    _emit("\tmov\t\trdi, rax");
    _emit("\tmov\t\trax, 60");
    _emit("\tsyscall");
}

/**
 * @brief generate x86-64 code from IR
 * @info foreach (line in _ir) { _emit(line); }
 */
void cplus::x86_64::Codegen::_generate()
{
    std::istringstream stream(_ir);
    std::string line;

    while (std::getline(stream, line)) {
        _trim(line);
        _generate_line(line);
    }
}

/**
 * @brief generate line
 * @info dispatch line to the appropriate emitter
 */
void cplus::x86_64::Codegen::_generate_line(const std::string &line)
{
    if (line.empty() || line.starts_with(";")) {
        return;
    }

    if (line.starts_with("func ")) {
        _emit_function_declaration(line);
    } else if (line == "{") {
        _emit_function_start();
    } else if (line == "}") {
        _emit_function_end();
    } else if (line.starts_with("label %")) {
        _emit_label(line);
    } else if (line.starts_with("%call")) {
        _emit_function_call(line);
    }
}

/**
* @brief functions
*
* @info routine:
*
* .globl        name
* name:    
*     push      rbp
*     mov       rbp, rsp
*     sub       rsp, <stack_size>
*     <function_body>
*     leave
*     ret
*/

/**
* @brief emit function declaration
*/
void cplus::x86_64::Codegen::_emit_function_declaration(const std::string &line)
{
    const std::string_view sv(line);

    if (!sv.starts_with("func @")) {
        return;
    }

    const u64 start = 6;
    const u64 end = sv.find('(', start);

    if (end == std::string::npos) {
        return;
    }

    const std::string_view func_name = sv.substr(start, end - start);

    _current_function = std::string(func_name);
    _emit(".globl\t\t\t" + _current_function);
    _emit(_current_function + ":");
    _function_set_stack_offset(&_stack_offset, _ir, _current_function);
    logger::info("function: ", _current_function, " stack offset: ", std::to_string(_stack_offset));
}

/**
* @brief emit function start
*/
void cplus::x86_64::Codegen::_emit_function_start()
{
    _emit("\tpush\trbp");
    _emit("\tmov\t\trbp, rsp");

    if (_stack_offset > 0) {
        _emit("\tsub\t\trsp, " + std::to_string(_stack_offset));
    }
}

/**
 * @brief emit function end
*/
void cplus::x86_64::Codegen::_emit_function_end()
{
    _emit("\tleave");
    _emit("\tret\n");
    _current_function.clear();
    _stack_offset = 0;
}

void cplus::x86_64::Codegen::_emit_label(const std::string &line)
{
    std::string label = line.substr(6);

    if (!label.empty() && label.back() == ':') {
        label.pop_back();
    }

    if (label.starts_with('%')) {
        label = label.substr(1);
    }

    _emit(".L" + label + ":");
}

void cplus::x86_64::Codegen::_emit_function_call(const std::string &line)
{
    const u64 at_pos = line.find('@');
    const u64 paren_pos = line.find('(', at_pos);
    const std::string func_name = line.substr(at_pos + 1, paren_pos - at_pos - 1);

    _emit("\tcall\t" + func_name);
}
